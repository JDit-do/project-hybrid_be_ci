name: CI on ECR

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_dispatch:
    inputs:
      minor:
        description: "target minor (예: 3) 또는 +1"
        required: false
        type: string

permissions:
  id-token: write
  contents: read

env:
  AWS_REGION: ap-northeast-2
  REPO_PREFIX: backend-service

jobs:
  build-all:
    runs-on: ubuntu-24.04-arm

    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_OIDC_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build & Push all top-level folders
        env:
          REGISTRY: ${{ steps.ecr.outputs.registry }}
          INPUT_MINOR: ${{ github.event.inputs.minor }}
          DEFAULT_MAJOR: "1"
          ALLOW_CREATE: "true" # Repository 생성 여부(true, false)
        shell: bash
        run: |
          set -euo pipefail

          NOW_TS=$(date -u +"%Y%m%dT%H%M%SZ")
          echo "CURRENT UTC: ${NOW_TS}"

          # 1-depth 폴더 수집
          mapfile -t FOLDERS < <(find . -maxdepth 1 -mindepth 1 -type d -printf '%P\n' \
                                  | grep -Ev '^\.(git|github|vscode)$' || true)
          echo "Top-level dirs: ${FOLDERS[*]:-<none>}"
          if [ ${#FOLDERS[@]} -eq 0 ]; then
            echo "No top-level folders found. Nothing to do."
            exit 0
          fi

          require_repo() {
            local repo="$1"
            
            # 존재하면 통과
            if aws ecr describe-repositories --repository-names "$repo" --region "${AWS_REGION}" >/dev/null 2>&1; then
              echo "ECR repo exists: $repo"
              return 0
            fi
            
            # 생성 비허용이면 실패 처리
            if [ "${ALLOW_CREATE}" != "true" ]; then
              echo "ERROR: ECR repo not found and creation disabled: $repo"
              return 1
            fi
            
            # 생성 시도
            echo "Creating ECR repo: $repo"
            aws ecr create-repository --repository-name "$repo" --region "${AWS_REGION}" >/dev/null 2>&1 || true
            
            # 생성/경쟁/권한 이슈 상관없이 최종 재확인
            if aws ecr describe-repositories --repository-names "$repo" --region "${AWS_REGION}" >/dev/null 2>&1; then
              echo "ECR repo ready: $repo"
              return 0
            fi
            echo "ERROR: Cannot ensure ECR repo: $repo (missing permission or invalid name)."
            return 1
          }

          for dir in "${FOLDERS[@]}"; do
            # Dockerfile 경로(대/소문자 허용)
            if   [ -f "$dir/Dockerfile" ]; then DOCKERFILE="$dir/Dockerfile"
            elif [ -f "$dir/dockerfile" ]; then DOCKERFILE="$dir/dockerfile"
            else
              echo "Skip $dir (no Dockerfile/dockerfile)"
              continue
            fi

            repo_name="${REPO_PREFIX}/${dir}"
            echo "=== Processing: $dir (Dockerfile: $DOCKERFILE) -> ECR repo: ${repo_name}"

            # ── A) 항상 빌드 (레포 상태와 무관)
            # 기존 semver 태그 수집 (vX.Y.Z)
            EXISTING=$(
              aws ecr describe-images \
                --repository-name "${repo_name}" \
                --query "imageDetails[].imageTags[]" \
                --output text 2>/dev/null | tr '\t' '\n' | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+$' || true
            )

            MAJOR="${DEFAULT_MAJOR}"
            # 현재 repo의 최대 MINOR 계산
            if [ -n "${EXISTING}" ]; then
              CUR_MINOR_MAX=$(printf '%s\n' ${EXISTING} \
                | awk -F'[v\\.]' -v maj="${MAJOR}" '$2==maj {print $3}' \
                | sort -n | tail -n1)
              CUR_MINOR_MAX="${CUR_MINOR_MAX:-0}"
            else
              CUR_MINOR_MAX="0"
            fi

            # 입력 해석: +1(마이너 증가) 또는 숫자(고정 마이너), 없으면 패치만 +1
            if [ -n "${INPUT_MINOR:-}" ]; then
              if [ "${INPUT_MINOR}" = "+1" ]; then
                MINOR=$(( CUR_MINOR_MAX + 1 ))
                PATCH="0"
              elif [[ "${INPUT_MINOR}" =~ ^[0-9]+$ ]]; then
                MINOR="${INPUT_MINOR}"
                PATCH_MAX=$(printf '%s\n' ${EXISTING:-} \
                  | awk -F'[v\\.]' -v maj="${MAJOR}" -v min="${MINOR}" '$2==maj && $3==min {print $4}' \
                  | sort -n | tail -n1)
                PATCH=$([ -z "${PATCH_MAX:-}" ] && echo 0 || echo $((PATCH_MAX + 1)))
              else
                echo "Invalid INPUT_MINOR='${INPUT_MINOR}' (use +1 or integer)"; exit 1
              fi
            else
              MINOR="${CUR_MINOR_MAX}"
              PATCH_MAX=$(printf '%s\n' ${EXISTING:-} \
                | awk -F'[v\\.]' -v maj="${MAJOR}" -v min="${MINOR}" '$2==maj && $3==min {print $4}' \
                | sort -n | tail -n1)
              PATCH=$([ -z "${PATCH_MAX:-}" ] && echo 0 || echo $((PATCH_MAX + 1)))
            fi

            VERSION_TAG="v${MAJOR}.${MINOR}.${PATCH}"
            echo "Resolved version for ${repo_name}: ${VERSION_TAG}"

            # 도커 빌드
            docker build -f "$DOCKERFILE" \
              -t "${REGISTRY}/${repo_name}:latest" \
              -t "${REGISTRY}/${repo_name}:${VERSION_TAG}" \
              "$dir"

            # ── B) 푸시 전에 레포를 '반드시' 보장. 실패 시 잡 실패로 종료.
            require_repo "$repo_name" || exit 1

            # 푸시
            docker push "${REGISTRY}/${repo_name}:${VERSION_TAG}"
            docker push "${REGISTRY}/${repo_name}:latest"
            echo "Pushed: ${REGISTRY}/${repo_name}:${VERSION_TAG} and :latest"
          done
